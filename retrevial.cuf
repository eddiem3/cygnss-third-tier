
!
! Define the INTERFACE to the NVIDIA CUFFT routines
!

module precision
! Precision control

integer, parameter, public :: Single = kind(0.0) ! Single precision
integer, parameter, public :: Double = kind(0.0d0) ! Double precision

integer, parameter, public :: fp_kind = Double
!integer, parameter, public :: fp_kind = Single

end module precision

module cufft

  use cudafor

  integer, public :: CUFFT_FORWARD = -1
  integer, public :: CUFFT_INVERSE = 1
  integer, public :: CUFFT_R2C = Z'2a' ! Real to Complex (interleaved)
  integer, public :: CUFFT_C2R = Z'2c' ! Complex (interleaved) to Real
  integer, public :: CUFFT_C2C = Z'29' ! Complex to Complex, interleaved
  integer, public :: CUFFT_D2Z = Z'6a' ! Double to Double-Complex
  integer, public :: CUFFT_Z2D = Z'6c' ! Double-Complex to Double
  integer, public :: CUFFT_Z2Z = Z'69' ! Double-Complex to Double-Complex


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  ! cufftPlan1d(cufftHandle *plan, int nx,cufftType type,int batch)
  !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


  interface cufftPlan1d
     subroutine cufftPlan1d(plan, nx, type, batch) bind(C,name='cufftPlan1d') 
       use iso_c_binding
       integer(c_int):: plan
       integer(c_int),value:: nx, batch,type
     end subroutine cufftPlan1d
  end interface cufftPlan1d

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  ! cufftDestroy(cufftHandle plan)
  !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  interface cufftDestroy
     subroutine cufftDestroy(plan) bind(C,name='cufftDestroy') 
       use iso_c_binding
       integer(c_int),value:: plan
     end subroutine cufftDestroy
  end interface cufftDestroy

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  ! cufftExecC2C(cufftHandle plan,
  ! cufftComplex *idata,
  ! cufftComplex *odata,
  ! int direction)
  !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  interface cufftExecC2C
     subroutine cufftExecC2C(plan, idata, odata, direction) &
          & bind(C,name='cufftExecC2C') 
       use iso_c_binding
       use precision
       integer(c_int),value:: direction
       integer(c_int),value:: plan
       complex(fp_kind),device:: idata(*),odata(*)
     end subroutine cufftExecC2C
  end interface cufftExecC2C

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  ! cufftExecZ2Z(cufftHandle plan,
  ! cufftDoubleComplex *idata,
  ! cufftDoubleComplex *odata,
  ! int direction);
  !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  interface cufftExecZ2Z
     subroutine cufftExecZ2Z(plan, idata, odata, direction) &
          & bind(C,name='cufftExecZ2Z') 
       use iso_c_binding
       use precision
       integer(c_int),value:: direction
       integer(c_int),value:: plan
       complex(fp_kind),device:: idata(*),odata(*)
     end subroutine cufftExecZ2Z
  end interface cufftExecZ2Z

end module cufft



module retrevial   
  
  implicit none

  real::windStart
  real::windSteps
  real::windInc
  real::xStart
  real::yStart

  real::xSteps
  real::ysteps

  real::xInc
  real::yInc
  real::lat
  
  
  type waveform
     !!!Location information
     !!Coordinate in Grid system
     real::x 
     real::y 

     real::lat

     real::windspeed !Wind speed at that point
     real::a !Willougby A parameter

     real::startX
     real::startY

     real::data(600)

  end type waveform

contains 


  !@param none
  !@return array of the configuration file

  function getWilloughby()
    
    type(waveform), allocatable, dimension(:)::getWilloughby
    
    
    integer::it !iterator for do loop
    integer::size = 56661 !Expected dimension of waveforms array
    
    integer::io

    real::x 
    real::y 
    
    real::lat
    
    real::windspeed !Wind speed at that point
    real::a !Willougby A parameter
    
    real::startX
    real::startY
    
    real::data(600)
    
    
    !type(waveform), allocatable ::waveforms(:) !An array to hold all waveforms
    allocate(getWilloughby(size))

    !io = 0

    !Open the model waveforms file
    write(*,*) "Loading configuation file..."
    open(1, file="Willoughby56_530-w.txt") 
    
    !Load configuration parameters
    read(1,*) windSteps, windStart, windInc, xSteps, ySteps, yInc, xInc, lat, xStart, yStart

    write(*,*) "The wind parameters are" ,windStart, windSteps, windInc   


    write(*,*) "Loading Model Waveform data. This may take a moment..."

    it = 1 !Iterator for do loop

    do
       it  = it + 1

       read(1,*, IOStat = io) x, y, windspeed, lat, a , startX, startY, data

       if(io > 0) then
          write(*,*) 'Check input. There was an error parsing the file'          
          write(*,*) 'The error number is:' ,io
          exit
       else if (io < 0) then
      
          write(*,*) 'Finished reading the Willoughby configuration file'
          exit
       else
          !Read the Willoughby config file
          !Load each model waveform into a waveform type
          !Place the waveform into the waveforms array
          !write(*,*) "Waveform:", x, y, windspeed, lat, a, startX, startY, data
          getWilloughby(it)%x = x
          getWilloughby(it)%y = y
          getWilloughby(it)%windspeed = windspeed
          getWilloughby(it)%lat = lat
          getWilloughby(it)%startX = startX
          getWilloughby(it)%startY = startY
          getWilloughby(it)%data = data
          write(*,*) int(real(it)/real(size) * 100) ,"% complete" 
       end if
    end do

    close(1)

  end function getWilloughby

  
  !Load gps chip data
  !@param None
  !@return a 2d array of the Nature Run data
  function natureRunData() 

    real, allocatable, dimension(:)::natureRunData !An array to hold all waveforms

    integer::index !index of data point, it dummy data to read the file
    real::xnr !latitude, x location
    real::ynr !longitude, y location
    real::data !signal data at that point

    integer::numWaves = 61 !total number of waveforms in the file
    integer::numPoints = 204 !the number of data points a wave form contains

    integer::io !IOStat error variable
    integer::i
    integer::j
        

    allocate(natureRunData(numWaves * numPoints))
    !allocate(natureRunData(100000))
    

    !real, dimension(numWaves, numPoints)::naturewave !An array to hold the points of the reference waveform


    write(*,*) 'Opening nature run data'
    !Open GPS Nature run file
    open(2,file='5KmH960wn2PvDel56_530_m50.txt')

    i = 0
    !Read in data
    do 

       read(2,*, IOSTAT=io) index, xnr, ynr, data

       if(io > 0) then
          write(*,*) 'Check input. There was an error parsing the file'
          write(*,*) "Error:", io
          exit
          
       else if (io < 0) then 
          write(*,*) 'Finished reading the nature run data'
          exit             
       else
          
          !write(*,*) i, index, xnr, ynr, data          
          natureRunData(i) = data
          i = i + 1
          
       end if
    end do
    !write(*,*) natureRunData
    close(2)

  end function natureRunData

  !Interpolate the nature run data 
  !ex expand nature wave data from 204 points to 600
  !@param naturwave - The nature run data
  !@return interpolate - The interpolated array
  function interpolate(naturewave) 
    
    real, allocatable, dimension(:)::interpolate !return array of the interpolated nature run dat
    real, allocatable, dimension(:), intent(in)::naturewave !input array of nature run data

    
    integer::i !iterator
    integer::j !iterator


    allocate(interpolate(size(naturewave)))
    

    interpolate(1) = 0
    
    do i=1, 200
       do j=1,3
          interpolate((i-1)*3+j)=naturewave(i+1)*(float(j-1)/3)+ naturewave(i)*(1-float(j-1)/3)
       end do
    end do
    write(*,*) interpolate
    write(*,*) "Finished interpolating the function"
    
  end function interpolate


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  !Computes the Cross Correlation 
  !between willougby modelwaveforms and nature run hurricane data
  !param: real, dimension(:)::waveforms - an array for model waveform data
  !param: real, dimension(:)::natureRunData - an array of real hurricane data
  !
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !subroutine crossCorrelate(waveforms, natureRunData)
      !use cufft
    


    !  end subroutine crossCorrelate

 

end module retrevial


program main
  use retrevial
  use cufft
  use precision
  implicit none




  !type(waveform), allocatable::modelwaveforms(:) 
  !real, allocatable, dimension(:)::naturewave
  !real, allocatable::interpolatedNatureRun(:)

  !modelwaveforms = getWilloughby()

  !naturewave = natureRunData()
  !write(*,*) shape(naturewave)

  !write(*,*) naturewave

  !interpolatedNatureRun = interpolate(naturewave)
  !write(*,*) interpolatedNatureRun


  complex(fp_kind) ,allocatable:: a(:),b(:)
  complex(fp_kind),device,allocatable:: a_d(:),b_d(:)

  integer:: n
  integer:: plan

  n=8

  ! allocate arrays on the host
  allocate (a(n),b(n))

  ! allocate arrays on the device
  allocate (a_d(n))
  allocate (b_d(n))

  !initialize arrays on host
  a=1

  !copy arrays to device
  a_d=a


  ! Print initial array
  print *, "Array A:"
  print *, a



  ! Initialize the plan
  call cufftPlan1D(plan,n,CUFFT_Z2Z,1)

  ! Execute FFTs
  call cufftExecZ2Z(plan,a_d,b_d,CUFFT_FORWARD)

  call cufftExecZ2Z(plan,b_d,b_d,CUFFT_INVERSE)


  ! Copy results back to host
  b=b_d

  ! Print initial array
  print *, "Array B"
  print *, b

  !release memory on the host
  deallocate (a,b)

  !release memory on the device
  deallocate 	(a_d,b_d)

  ! Destroy the plan	
  call cufftDestroy(plan)	


  
end program main














 


